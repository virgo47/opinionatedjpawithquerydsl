# Removing *to-one* altogether {#ch-without-to-one}

W> This solution builds on JPA 2.1 `ON` clause but is not JPA compliant because it also uses
W> root entity after `JOIN` keyword that is only supported in EclipseLink and not according to
W> [[JPspec](#bib-jpspec)]. Specification details this on page 176 and the following sections
W> 4.4.5.x. I discovered this option when I played with Querydsl
W> and various options how to state my joins -- and it worked on the reference implementation!
W> With this I was more than a year in a mistake that we're bending JPA, using it as it was not
W> intended, but still within the rules. I hit the wall when I tried it with Hibernate in course
W> of writing this book. Checking with the specification I realized I ran into serious troubles
W> and got caught by the irony of me saying "JPA is hard and complex".
W>
W> Sure there is "nobody's fault but mine" part to it. I experimented trying to fight JPA. I tried
W> to get us from the quagmire of that ORM Vietnam and got us into another quagmire, still in ORM
W> war, obviously -- but now out of specification fences. There is no real problem for us as we
W> cannot switch to Hibernate with the project easily anyway (for Hibernate real bugs for a
W> change), but when using ORM on Java I always voted for JPA way (well, since *JPA 2.0* at least).
W> In the meantime Hibernate joined the "crowd" supporting entity joins with its 5.1.0 release
W> (February of 2016), so this solution is not an obstacle when migrating between major
W> JPA providers.
W>
W> The solution -- or a pattern if you will -- is interesting enough to be presented and with
W> backing of major providers also readily available. I'd just be more happy if the option for
W> joining root entities was in the specification. To that end I also filed
W> [an issue](https://java.net/jira/browse/JPA_SPEC-128), although the recent (non-)activity on
W> that Jira project lets me wonder where all the JPA developers/specifiers are.[^eeinact]

[^eeinact]: The whole Java EE 8 is kind of dormant as of 2016.

To get full control over the fetching -- and to do it without any high-tech solution -- we have to
drop the relation and map row foreign key instead. Before we go on, we will discuss the important
addition of the `ON` keyword in *JPA 2.1*.


## Why do we need `ON` anyway?

`ON` was dearly missing for other practical reasons. While this does not relate to *to-one*
mapping, let's see an example:

![Class diagram of our entity model for 'ON' demo](images/on-clause-example.png)

Here the `Breed` does not have a name, only some synthetic code, and names are offered in multiple
languages thanks to `BreedLocalizedName`. Demo code is
[here](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/on-with-to-many/src/test/java/OnDemonstration.java).
Our favourite breeds are:

* wolf, with code `WLF` and localized names for English and Slovak (*wolf* and *vlk* respectively
-- and yes, I know a wolf is not a dog),
* collie, with code `COL` with localized name available only for Slovak (k√≥lia).

Now imagine we want to get list of all breeds with English names. If the localized name is not
available for our requested language, we still want to see the breed with its code in the list in
any case. This may seem ridiculous to SQL guys, but it's a real problem for some Java programmers.
The first naive attempt may be:

{title="Naive `JOIN` to localized names", lang=java}
~~~
QBreedLocalizedName qbn = QBreedLocalizedName.breedLocalizedName;
List<Tuple> breedEnNames = new JPAQuery<Breed>(em)
  .select(QBreed.breed.id, QBreed.breed.code, qbn.name)
  .from(QBreed.breed)
  .join(QBreed.breed.names, qbn)
  .where(qbn.language.eq("en"))
  .fetch();
~~~

But this produces unsatisfiable results containing only `[1, WLF, wolf]`. "When I join the
localized names to the breed list some results are gone!" our programmer complains. Ok, let's
introduce the `LEFT JOIN` concept to them. Next attempt:

{title="`LEFT JOIN` without `ON` clause", lang=java}
~~~
breedEnNames = new JPAQuery<Breed>(em)
  .select(QBreed.breed.id, QBreed.breed.code, qbn.name)
  .from(QBreed.breed)
  .leftJoin(QBreed.breed.names, qbn)
  .where(qbn.language.eq("en"))
  .fetch();
~~~

It seems promising at first, but the result is again only a single lone wolf. There is one
difference though, although the `WHERE` clause wipes it out. If there was any breed without any
localized name at all it would be preserved after the `JOIN`. `WHERE` eliminates it only because
the value for `language` column would be `NULL` and not "en". We could try to overcome it by an
additional `.or(qbn.language.isNull())` in the `WHERE` part, but this would work only for rows
with no localized name -- but not for those who have missing "en" localizations.

The trick is that the condition must be part of the `LEFT JOIN` -- and that's what `ON` is all
about. Let's do it right after all:

{title="`LEFT JOIN` with `ON` clause", lang=java}
~~~
breedEnNames = new JPAQuery<Breed>(em)
  .select(QBreed.breed.id, QBreed.breed.code, qbn.name)
  .from(QBreed.breed)
  .leftJoin(QBreed.breed.names, qbn).on(qbn.language.eq("en"))
  .fetch();
~~~

And, voila, the result is `[1, WLF, wolf], [2, COL, null]` -- with collie as well, although
without the name localized to English. Now we could add another condition to filter these cases
and report them -- `.where(qbr.name.isNull())` would do the trick, this time as a `WHERE` clause.

But this is the essence of `ON`. It's a special `WHERE` that works very closely with related
`JOIN` and while the difference is virtually none for inner joins, it is essential for those outer
ones.

D> When you used `LEFT JOIN` in JPQL you actually implied SQL `ON` clause undercover with JPA before
D> version 2.1 as well. When you LEFT JOIN `breed.names` to `breed`, JPA determines the content
D> for underlying SQL `ON` clause from the mapping -- naturally it is that the primary key from one
D> table equals the foreign key of the other. This works fine if you follow *to-one* relations and
D> join optional relations to existing rows.
D>
D> The situations changes dramatically if you follow to-many relations and want to select a
D> concrete one for each row with particular conditions (like a language in our example). This left
D> you in the dark with previous JPA versions. That's why the addition of `ON` is so important for
D> these cases.


## Dropping *to-one* annotations

Having accepted that we're out of pure JPA land it is otherwise easy to get rid of *to-one*
relationships. Instead of:

{title="To-one as we know it", lang=java}
~~~
@ManyToOne
private Breed breed;
~~~

We can simply map the raw value of the foreign key:

{title="Mapping raw foreign key", lang=java}
~~~
@Column(...)
private Integer breedId;
~~~

If you want to load `Breed` by its ID, you use `EntityManager.find` explicitly. This has domain
consequences, because unless we give the entities some way to get to entity manager, such a code
cannot be directly on the entity. We will try to mend it and bridge this gap that JPA automagic
creates for our convenience -- which is a good thing, and better part of the abstraction. The point
is there is no technological problem to obtain the referenced entity by its ID.

Queries are where the problem lies. Firstly, and this cannot be overcome with current JPA, we need
to use root entity in the `JOIN` clause -- both EclipseLink and Hibernate now allow this.
This enriched experience cuts both ways, of course, as we may believe we're still in JPA world
when we're in fact not (my story). Second thing we need is `ON` clause, which is something *JPA 2.1*
provides. As discussed at the end of previous sections, `ON` clauses were generated for joins
before -- but only as implied by the mapping and a particular *association path* used in the join.
We need to make this implicit `ON` condition explicit. Let's see an example:

{title="JOIN to root entity and explicit ON", lang=java}
~~~
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .leftJoin(QBreed.breed).on(QBreed.breed.id.eq(QDog.dog.breedId))
  .where(QBreed.breed.name.contains("ll"))
  .fetch();
~~~

The key part is how the `leftJoin` is made. Querydsl doesn't mind at all that we're breaking JPA
rules here, it allows root entity and produces JPQL that works the same like the following code:

{title="JPQL equivalent", lang=java}
~~~
List<Dog> dogs = em.createQuery(
  "select dog from Dog dog left join Breed breed on breed.id = dog.breedId" +
  " where breed.name like '%ll%'", Dog.class).getResultList();
~~~

So this leaves us covered. Queries are just a bit more explicit, but otherwise nothing you would
not write into your SQL. We can argue that this way we can compare that `breedId` with any other
integer and we're loosing the safety that ORM mapping gives us. On the mapping you specify what
columns are related on a single place and not in each query. This is true, indeed, although not
really a big deal. When talking to your DB admins they will probably see even better what you do,
although smart DBAs have no problem to understand JPQL either. But with dropping the mapping we're
loosing this comfort too. In theory we could leave some logical mapping information on the
attribute, but without redesigning JPA we cannot benefit it in our queries anyway. We will try to
tackle the problem of missing metadata on the plain FK-typed attribute later in this chapter.


## Loading the relation from the entity

Queries are typically executed in the context out of the object itself -- in a repository or DAO,
you name it. There is no problem to get hold of `EntityManager` at these places. But if you want
some loading from your entity, things necessarily get a little messy. But before we get to the
messy part let's step back a little, because we have two broad options how to do it:

* We can have a real object attribute, but `@Transient`, and we can load it when the scenario
requires it. This is actually pretty handy because you can load the entity with its relations
with an optimized query -- especially if you don't expect that data in the cache, or don't want
to use the cache at all, etc. Very explicit, but does exactly what it says. This does not require
us to put any infrastructure code into the entity as we fill the attribute from the outside in a
code that loads the whole object graph.
* We can load it lazily when and if needed. But we have to make explicit what JPA does under the
surface and what we don't see on the entity -- or we can develop our solution, but I'm not sure
it's worth it for this problem.

The first solution is obvious, so let's see what we can do about the other one. Let's start with
adding the method returning our entity -- in our case we have a `Dog` with `breedId` foreign key
mapped as a raw value of type `Integer`. To load the actual entity we may try something like:

{title="Getter loading entity by id", lang=java}
~~~
public Breed getBreed() {
  return DaoUtils.load(Breed.class, breedId);
}
~~~

Ok, we cheated a bit, I admit -- we moved the problem to that `DaoUtils`, but for a good reason.
We will need this mechanism on multiple places so we want it centralized. That `load` method then
looks like this:

{title="Loading the entity", lang=java}
~~~
public static <T> T load(Class<T> entityClass, Serializable entityId) {
  EntityManager em = ...; // get it somehow (depends on the project)
  return em.find(entityClass, entityId);
}
~~~

Ouch -- two examples, cheating on both occasions. But here I cannot tell you how to obtain that
entity manager. The method can reach to a Spring singleton component that makes itself accessible
by static field, for instance. It isn't nice, but it works. The point is that entity is not
a managed component so we cannot use injection as usually. Static access seems ugly, but it also
frees the entity from a reference to some infrastructural component and leaves it only with
dependency to some utility class.

It is important to be familiar with the implementation of an injected `EntityManager` -- in case of
Spring their shared entity manager helps us to get to the right entity manager even if we get to
the component via static path. I would probably have to consult Java EE component model to be sure
it is possible and if it is reliable across application servers.

Other option how to smuggle in the entity manager utilizes a `ThreadLocal` variable, but this means
someone has to populate it which means life-cycle -- and that means additional troubles.

In any case, it is possible to add getter for a relationship on the entity, but it calls for some
rough solutions -- so if you can keep such an access somewhere else (data access object, for
instance) do it that way. Otherwise we're getting dangerously close to [*Active record*
pattern](https://en.wikipedia.org/wiki/Active_record_pattern) which by itself is legitimate, but
doesn't fit JPA. True -- JPA provider can cheat somehow undercover, but we rather should not.

If you decide to load the relationship in some arbitrary code and you have only access to the
entity, perhaps you can introduce DAO to that code. If you feel you're making this decision too
high in the layer model (like on the presentation layer maybe?), perhaps it should be pushed lower
where the DAO is available. I'm not totally against static backdoor from the non-managed code to
the managed component, but at least we should be aware of the cost and compare it with the cost
of not doing it.


## Loosing information without mapping annotations

When we map foreign key instead of the relationship we often loose important piece of information
-- that is what type it leads to. Sometimes it is clear, e.g. with `Integer breedId` you can easily
guess it leads to `Breed`. But there is no type declaration anywhere around to click on when using
IDE. Even worse, the foreign key often describes the role instead of the type -- which I personally
prefer especially when there are multiple relationships of the same type. So instead of terrible
`client1Id` and `client2Id` you have `ownerId` and `counterpartyId`. The names are descriptive, but
the type information is gone altogether.

For this -- and also for means to automatically check validity of these IDs for newly stored or
updated entities -- we developed custom `@References` annotation. With it the mapping for a foreign
key may look like this:

{title="Using `@References` annotation", lang=java}
~~~
@References(type = Breed.class, required = true)
private Integer breedId;
~~~

I believe the documentation factor is the most important one here, but we can also check the
references on an entity like this:

{title="Using `ReferenceChecker`", lang=java}
~~~
new ReferenceChecker(em).checkReferences(lassie);
~~~

This either does nothing when everything is OK, or it fails with some exception of your choice
depending on how you implement it. Our version is similar to [this example](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/examples/many-to-one-raw/src/main/java/support/ReferenceChecker.java)
on GitHub. If you go through the code you notice that it can do more than just checking -- it can
also push the real entities to some transient fields, for instance. Such a mechanism can be
easily incorporated into validation framework you use if you wish to.


## JPA dual mapping

When I say dual mapping I mean mapping of the relation both as an object and foreign key value.
It looks like this:

{title="Dual relation mapping", lang=java}
~~~
@Entity
public class Dog {
...
  @ManyToOne
  @JoinColumn(name = "breed_id", updatable = false, insertable = false)
  private Breed breed;

  @Column(name = "breed_id")
  private Integer breedId;
~~~

I can't find example of this anywhere in the [[JPspec](#bib-jpspec)], neither can I find anything
that would forbid it (although I'm not really sure) -- but it works in both major JPA providers.
The key is marking one of these attributes as readonly, that's what `updatable/insertable=false`
does. I prefer this version as now I don't need any `Breed` object for update when I have its ID
already. Getters are returning values for respective fields, setters are designed in such a way
that the persisted field (here foreign key value) is always updated:

{title="Accessors for dual mapping", lang=java}
~~~
public Breed getBreed() {
  return breed;
}

public void setBreed(Breed breed) {
  this.breed = breed;
  breedId = breed.getId();
}

public Integer getBreedId() {
  return breedId;
}

public void setBreedId(Integer breedId) {
  this.breedId = breedId;
}
~~~

In this case it means merely setting the `breedId` field when `breed` is updated. We don't care
about `breed` in the other setter. Programmer has to know that foreign key value is primary
breed attribute here and act accordingly. For instance, this setup is not transparent when
persisting new entities. If we persist a fresh breed there is no guarantee its ID is already
available as autoincrement fields are filled in after the actual `INSERT` is flushed to the
database. With EclipseLink we have to force it if we need the ID -- calling `setBreed(newBreed)`
would otherwise set dog's FK to the breed to `null`. Hibernate is rather eager with `INSERT`s which
is convenient for this scenario.

Reverse case -- with `breed` as the persisted field and `breedId` as the readonly one -- is less
useful and I cannot find any reasons to use it instead of the traditional JPA relationship mapping.
You can get foreign key value anytime calling `breed.getId()`.

In any case, there are no "savings" during the load phase, but we can store new entities with
raw foreign key values if we have those (and for whatever reason don't have the entities loaded).
In the previous chapter we mentioned the possibility of using entities as wrappers for the foreign
key, but we also showed that it doesn't play well with `cascade = PERSIST`.

If we go back to dreaming -- imagine we could request `em.find` for a dog by ID with a hint *not
to load readonly mappings* (or otherwise designated). This would save us the hassle during the
loading phase as well and made the whole read-update scenario (part of typical CRUD) based on
foreign key values with the opportunity to load the relationships -- if we wished so. Any of this
could be specified on the entity level based on typical patterns of usage. *Imagine all the people
fetching like they want-oh-oh...*

Dual mapping like this has one big advantage compared to the pure foreign key mapping -- with
the `breed` mapping we can construct JPA compliant JPQL queries without waiting for the next
version of JPA -- if they bring the option of joining root entities at all, that is. But currently
dual mapping also means that we can only avoid the fetch cascade if we:

* rely on `LAZY` hint -- not guaranteed by JPA, but if provided by a provider, you can consider
it solved;
* or query the entity with all the columns named explicitly (e.g. include `breedId`, skip `breed`)
-- this, however, cripples the caching (if you use it) *and* is annoying to code.

I> There actually is something similar to this "dual mapping" mentioned in the
I> [[JPspec](#bib-jpspec)]. It relates to mapping of relations that are part of the primary key
I> and involves `@MapsId`. The specification describes this in the section *2.4.1* and examples
I> therein, also see *11.1.39*. For instance, instead of combined `@Id` and `@OneToOne` mapping
I> when primary key is also a foreign key to some master entity you may want to have `@Id` as a
I> value and separate `@OneToOne` mapping. In such a case you override `@JoinColumn` (not `@Column`
I> for `@Id`) and you add `@MapsId` that tells JPA that this mapping and `@Id` mapping play
I> together. `@MapsId` can relate to one column or more columns when the referenced entity uses
I> composite primary key and can be useful for `@OneToOne` or `@ManyToOne`.
I>
I> However, you don't need this annotation if you use `@IdClass` instead of `@EmbeddedId`. That's
I> actually why I never saw this annotation before I started working on this book -- we prefer
I> `@IdClass` annotations.


## Wrapping it up

I presented a solution to our *to-one* problems -- to use raw foreign key values. This bends the
JPA rules a bit and builds on the availability of the `ON` clause introduced in *JPA 2.1*. However,
JPA specification currently does not allow us to use root entity paths with `JOIN`s -- which is
required for queries. Only association paths are allowed now. This feature may come in later
versions and it is already supported by EclipseLink and DataNucleus, but not by Hibernate, for
instance.

Mapping raw foreign key value may lead to some logical information loss, which can be easily
mended by custom annotation. I'd like to see standard JPA annotation for this, otherwise schema
generation would not be fully functional.

Alternative solution might be dual mapping -- mapping both the foreign key value and the relation
as object. When mapping more attributes for a single column we have to designate other mappings
as read-only. If we could explicitly ask JPA to fetch the object -- or ask it not to fetch -- we
would have much better control over the fetching cascade going wild.

Another solution is to use a single mapping like today and having hint for JPA to fetch only the ID
portion of the related object. This may not work well with `cascade=PERSIST` when persisting new
entities pointing to existing ones, although the specification allows it to work (but also allows
to throw exception thanks to magical usage of "may" in the specification text). This solution
preserves current query mechanics, and actually is least intrusive of them all.

Finally, the JPA specification could mandate `LAZY` -- this is something where Hibernate seems
quite reliable out of the box without any configuration hassle. On the other hand, I saw many
questions asking how to make this relation lazy in Hibernate, so it probably is not universally
true. Promoting `LAZY` from a hint to a guaranteed thing would require JPA providers to use some
bytecode magic (which is not clean from Java language perspective), but it would also end a lot of
debates how to do it right.